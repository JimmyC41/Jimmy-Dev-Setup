# Cursor Rules

## Rule Precedence & Scope
- Precedence order:
  1) Explicit user instructions
  2) Repository / project conventions
  3) These rules
- Enforce rules only when relevant to the user’s request and touched code.
- Limit changes to requested files and scope unless explicitly approved.
- If a rule conflicts with repo conventions or user intent, ask or defer.

## User Ownership & Authority
- The user owns architecture, APIs, interfaces, types, and module boundaries.
- Do not invent or modify APIs, interfaces, or types unless explicitly instructed.
- If an API change appears necessary, propose options and tradeoffs; do not implement without approval.
- Guide via questions, constraints, and tradeoffs; implementation help is allowed.
- Prefer the smallest change that satisfies the request; do not refactor unrelated code.

## Interaction Discipline
- Write neutral, professional, concise bullet points.
- Avoid narrative prose, emojis, exclamation marks, and unnecessary summaries.
- Do not write code unless explicitly requested.
- If requirements are unclear:
  - Ask clarifying questions only if blocking.
  - Otherwise proceed with explicit assumptions.
- Do not invent edge cases, failure modes, or test paths; ask the user to enumerate them.

## Design & Abstractions
- Do not introduce abstractions or patterns without a concrete second use.
- Suggest design patterns only when the user’s design matches the pattern’s intent.
- When suggesting a pattern: map problem → intent → fit (2–3 sentences).
- Default to composition; justify inheritance when used.
- Prefer conventional, idiomatic C++ over clever techniques.
- Call out non-obvious costs only when relevant (allocation, copies, locking, cache effects).

## Dependency & API Design
- Prefer not to expose third-party types in stable/public APIs.
- If third-party types are already exposed, do not refactor without clear benefit and approval.
- Confine third-party usage to a small number of well-defined adapter/module boundaries.
- Apply Dependency Inversion: interfaces live with high-level policy.
- Apply ISP: no interface should force unused methods.

## Naming
- Follow repository naming conventions if present.
- Otherwise default to:
  - Types, functions: PascalCase
  - Variables, namespaces, filenames: lower_snake_case
  - Private members: m_lower_snake_case
  - Constants: kCamelCase
  - Filenames: lower_snake_case (.h / .cc)

## Comments & Documentation
- Comments must add information; never restate the code.
- Use complete sentences; consistent tone.
- TODOs require tracking ID and owner where applicable.
- File-level: describe user-facing abstractions.
- Class-level: purpose + intended usage; example if non-obvious.
- Declaration-level (API/contract): behavior, inputs→outputs, pre/postconditions, ownership/lifetime/nullability.
- Definition-level: implementation-specific notes only.
- Prefer strong types and names over per-argument comments; parameter docs acceptable for public APIs when needed.

## Logging & Observability
- Logs must allow reconstruction of end-to-end flow and decisions.
- Non-trivial logs require correlation context (stable ID + phase + minimal state).
- Flag hot-path risks (formatting, allocations, volume); log at boundaries or decisions.
- Flag non-actionable logs (generic, duplicated, low-signal).
- Avoid logging secrets or sensitive data.

## C++: Headers & Structure
- Every .h must compile standalone and use include guards or #pragma once.
- Include what you use; forward declare only when storing pointers/references.
- Public headers should not contain non-trivial method bodies.
  - Exception: templates, header-only code, or trivial inline functions.
- Include order with one blank line between groups:
  1) Corresponding header
  2) C headers
  3) C++ standard headers
  4) Third-party headers
  5) Project headers
- Use project-relative includes; <...> only for standard or required third-party headers.

## C++: Namespaces & Linkage
- Avoid symbols in the global namespace; use named namespaces.
- Never use `using namespace`.
- Close multi-line namespaces with trailing comments.
- Prefer single-line nested namespace syntax.
- In .cc files, give file-local symbols internal linkage (unnamed namespace).

## C++: Functions & Parameters
- Declare variables in the smallest scope; always initialize locals.
- Prefer return values over output parameters.
- Avoid owning raw pointers.
- Use references for non-null inputs; pointers for nullable or optional semantics.
- Optional inputs:
  - std::optional<T> for by-value
  - const T* when the non-optional form is const T&
- Optional outputs/in-out: T* (nullptr = not provided).
- Input-only parameters precede output/in-out parameters.
- Avoid hidden lifetime coupling across calls.
- Flag functions with multiple responsibilities or deep nesting.
- Use trailing return types only when ordinary syntax is impractical.

## C++: State & Lifetime
- Avoid symbols in the global namespace.
- Do not create classes solely to group static members.
- Global/static objects allowed only if trivially destructible or with clear shutdown ordering.

## C++: Classes
- Constructors must not call virtual functions.
- Constructors must not perform failing work unless failure is representable by the project’s error model.
- Single-argument constructors and conversion operators must be explicit unless intentional and safe.
- Support copy/move only when semantics are correct.
- Use struct only for passive aggregates.
- Prefer named structs over pair/tuple.
- Operator overloads must reflect natural value semantics.
- Data members must be private unless const or in test fixtures.

## C++: Declaration Order (public → protected → private)
1) Types/aliases
2) Static constants
3) Factory functions
4) Constructors/assignments
5) Destructor
6) Other methods
7) Data members
- Do not place large method bodies inline.

## C++: Modern Usage
- Prefer smart pointers with single, explicit ownership.
- Use rvalue references only for move ops, &&-qualified consumers, or perfect forwarding.
- Avoid RTTI unless required.
- Prefer C++ casts; avoid C-style casts.
- Prefer prefix ++/-- unless postfix is required.
- operator<< only for value-like, user-visible types.

## C++: Const & Compile-Time
- Use const T& / const T* for unmodified reference/pointer parameters.
- Do not add const to by-value parameters in public APIs.
- Mark methods const unless logical state changes.
- Use constexpr only for true compile-time constants.
- Use constinit for non-constant globals/statics.

## Types & Portability
- Use fixed-width integers when size matters.
- Use unsigned only for bitfields or modular arithmetic.
- Use float or double only.
- Avoid reliance on non-portable type sizes or CPU-specific behavior.

## C++: Macros & Language Features
- Avoid macros, especially in headers.
- Use nullptr (not NULL); use '\0' for null char.
- Prefer sizeof(var) over sizeof(type) unless clarity requires otherwise.
- Use auto only when it improves readability or avoids repetition.
- Prefer explicit lambda captures when lifetimes may extend.

## C++: Switch Statements
- Non-enum switches require a default case.
- If default is unreachable, fail fast (assert or log+abort).

## Unit Testing
- Require the user to specify intended test paths.
- If missing, ask the user to enumerate relevant categories (e.g., happy path, boundaries, invalid input, error propagation, concurrency).
- Do not add test cases beyond what the user confirms.
- No sleeps or time-based asserts; use deterministic fakes or clocks.
- Avoid repeated raw TEST() blocks with similar EXPECTs.
- Use fixtures for shared setup.
- Prefer table-driven, parameterized tests for IO-style behavior:
  - Input / Expected structs
  - IOCase { name, in, out }
  - Single TEST_P over ValuesIn(cases)
- For shared setup + params, combine base fixture with WithParamInterface.